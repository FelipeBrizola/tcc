\chapter{\label{chap:chap3} Proposta de trabalho}

Seguindo a organização arquitetural da Figura \ref{fig:fig1}, a proposta deste trabalho é fazer com que um \textit{fog node} conheça, de forma autônoma, os recursos disponibilizados por seus vizinhos.
Assim, cada \textit{fog node} saberá quais são os \textit{edge devices} disponíveis na rede, portanto,
o nodo que possui o sensor de chuva saberia que existe um outro nodo na rede capaz de medir a temperatura, por exemplo.


Podemos observar na topologia da Figura \ref{fig:fig1}, que os \textit{fog nodes} não possuem uma um nodo central como servidor.
Em razão da topologia distribuída, se for necessário escalarmos a quantidade de nodos na rede, a mesma não deverá sofrer impactos significativos de performance.

Nas seções a seguir abordaremos a arquitetura, módulos e submódulos que compõem o projeto, bem como resultados esperados, validações e cenários de teste. 

\section{Arquitetura}

Esta Seção define a pilha de protocolos a serem utilizados neste projeto, bem como a justifica pela escolha dos mesmos.
A pilha de protocolos atuará em conjunto com a organização arquitetural previamente definida na Figura \ref{fig:fig1}.

A fim de facilitar a compreensão da arquitetura deste projeto, a Figura \ref{fig:fig2} explicita a pilha de protocolos que o projeto fará uso para implementar as funcionalidades propostas.

\begin{figure}[htb!]
    \centering\includegraphics[width=.5\textwidth]{fig2.pdf}
    \caption%[This figure has a shorter caption now]%
    {\label{fig:fig2} Pilha de protocolos.}
\end{figure}

O modelo de referência TCP/IP é constituido de cinco camadas: física, enlace, rede, transporte e aplicação \cite{tanenbaum2011redes}.
Nesse trabalho, o níveis de rede e transporte (IPv4 e UDP respectivamente) serão utilizados para a implementação do modelo proposto.

A utilização de IPv4 na camada de rede justifica-se pelo fato do protocolo ser empregado em redes locais, que geralmente não necessitam de uma quantidade de endereçamento tão grande 
se comparado ao IPv6, mas não existem impedimentos para que implementações futuras utilizem IPv6 na camada de rede.

Manter o contexto de conexão entre os nodos, utilizando TCP por exemplo, despenderia uma quantidade de trafego desnecessário na rede.
Visto que a simplicidade é um dos objetivos deste trabalho e que transitar uma pequena quantidade de dados a cada requisição aumenta o desempenho da solução,
a utilização de datagramas UDP faz sentido neste protocolo

O protocolo proposto, entitulado \textit{Resource Mapping}, como apresentado na Figura \ref{fig:fig2}, atuará na camada de aplicação do modelo de referência TCP/IP \cite{tanenbaum2011redes} e será responsável por padronizar, descobrir e sincronizar os nodos da névoa.
Os maiores desafios neste modelo proposto são manter o estado global dos recursos acessível a todos os nodos, e garantir que o desempenho seja satisfatório com o objetivo permitir a escalabilidade da solução.



\section{Módulos}

De forma geral, cada nodo da rede deverá manter uma lista com os endereços IP`s que fazem parte do mapeamento.
Atrelado à cada endereço IP, deverá haver uma lista com os recursos providos por este.
Em vista disso, cada nodo portará um mapeamento global de recursos disponíveis na névoa.

% SJF: Podes dar a dica aqui (sem entrar em maiores detalhes) de que o mapeamento de recursos será atualizado sob demanda o que implicará em uma menor necessidade de tráfego para manter o estado global atualizado e permitirá uma maior escalabilidade de nodos / recursos.

O detalhamento das funcionalides que o projeto deverá dispor, bem como ilustrações relacionadas aos fluxos, serão abordadas nas proximas subseções.

\subsection{Middleware}

Observando a Figura \ref{fig:fig1}, notamos que há comunicação entre um fog node e seus respectivos edge devices.
A comunicação entre estes não é o foco deste projeto, portanto, será tratada de forma simulada.
Assim sendo, a simulação deverá prever alguns casos que, por vezes, possam suceder. Dentre alguns dos eventos possíveis está
o acréscimo ou remoção de um edge device vinculado à algum fog node.

A manutenção dos recursos, acréscimo ou remoção, transcorrerá utilizando o protocolo CoAP.
Utilizar CoAP para estas funcionalidades faz sentido, uma vez que este prevê meios para vinculação de recursos a nodos.

Segundo a definição de POST do protocolo CoAP, sua função é determinada pelo servidor que está recebendo a requisição e pelo do recurso referenciado na URI.
Geralmente a sua utilização resulta na criação ou atualização de um recurso.\cite{rfc7252}.
Já a mesma RFC define o método DELETE como sendo um método de remoção de recursos baseado em URIs\cite{rfc7252}.

Nessa perspectiva, portanto, o uso do método POST faz sentido para gerarmos \textit{(CoRE) Link Format} e o método DELETE para removermos.


\subsection{Descoberta de recursos}


Partindo do pressuposto que os nodos da névoa já possuem seus recursos devidamente criados e acessíveis via CoAP,
como primeiro passo do mapeamento devemos considerar a entrada de um novo nodo na rede.
No momento em que o nodo dispor de um endereço IP válido, este deverá enviar um pacote para o endereço de broadcast indicando que possui recursos a serem disponibilizados.


Ao receberem o pacote enviado por broadcast, os nodos que desejarem saber quais recursos estão sendo providos por este novo membro, deverão realizar uma query
unicast para a URI \textit{/.well-known/core} utilizando o protocolo CoAP.
Vale lembrar que este fluxo de requisição e resposta, utilizando a URI \textit{/.well-known/core}, faz com que o nodo requisitado retorne todos seus recursos ao solicitante.


Com o objetivo de exemplificar a primeira fase do protocolo, as Figuras \ref{fig:fig5} e \ref{fig:fig6} apresentam o fluxo para a descoberta de recursos.

%  mencionar q cada fog tem edge devices
A topologia da névoa utilizada nas imagens é definida por fog nodes enumerados de um à cinco, sendo o nodo FN5 o ultimo a entrar na rede.
A figura \ref{fig:fig5} demonstra o nodo FN5 entrando na névoa e, portanto, deverá anunciar-se por broadcast indicando que possui recursos a serem disponibilizados.

\begin{figure}[htb!]
    \centering\includegraphics[width=.5\textwidth]{fig5.png}
    \caption%[This figure has a shorter caption now]%
    {\label{fig:fig5} Nodo entrando na névoa.}
\end{figure}

Após FN5 enviar mensagem  “Hello“ por broadcast, os nodos FN1, FN2 e FN4 realizam a query diretamente ao FN5 afim de obter os recuros disponíbilizados por ele,
já o nodo FN3, por não estar executando o protocolo de mapeamento, não.


\begin{figure}[htb!]
    \centering\includegraphics[width=.5\textwidth]{fig6.png}
    \caption%[This figure has a shorter caption now]%
    {\label{fig:fig6} Nodos realizando query.}
\end{figure}


\subsection{Gerenciamento de recursos}

A manutenibilidade da lista de recursos globais é relevante para que a implementação do protocolo tenha sucesso, pois, a névoa deverá saber quando um nodo, ou recurso dele, deixou de fazer parte rede.
Para tal, faz-se necessário a utilização de alguns mecanismos de controle.
Esses controles são realizados em duas esferas, a primeira trata da inserção ou remoção de um nodo na rede,
já a segunda refere-se a inserção ou remoção de um edge device, vinculado a um nodo qualquer.
% SJF: Ta um pouco confuso esse parágrafo. Tenta remover as vírgulas, reescrevendo e mudando um pouco o estilo.



Inicialmente abordaremos a entrada e saída de nodos da névoa, e para esta subseção será utilizado o cenário da Figura \ref{fig:fig6} quando necessário.
O Pseudocódigo \ref{alg:alg1} demonstra, de forma sucinta, a política de atualização que cada nodo deverá implementar.

\begin{algorithm}[htb]
    \begin{center}
        \begin{algorithmic}[1]
            \STATE \textbf{function} $\text{Police(ip, resources)}$
            \STATE \hspace{\algorithmicindent} \textbf{if} $\text{exists(ip)}$
            \STATE \hspace{\algorithmicindent} \hspace{\algorithmicindent} $\text{update(ip, resources)};$
            \STATE \hspace{\algorithmicindent} \textbf{else}
            \STATE \hspace{\algorithmicindent} \hspace{\algorithmicindent} $\text{insert(ip, resources)};$
        \end{algorithmic}
    \end{center}
    \caption[Política de atualização de recursos]%
        {\label{alg:alg1} Política de atualização de recursos.}%
    \end{algorithm}

No momento em que o nodo recebe a resposta de sua query, contendo os recursos providos pelo nodo requisitado, aquele deverá armazenar as informações em uma estrutura de dados adequada.
Essa estrutura de dados estará implementada em todos os nodos da névoa, e a partir dela será possível realizar o gerenciamento dos recursos de forma simples e eficiente.
O trecho abaixo define, por ora, o formato dos dados que serão utilizados em cada nodo.


% SJF: query -> requisição


\begin{verbatim}
    Fog = {
        string ip;
        string resources[];    
    }
    Fog fogs[];
    string myResources[];
\end{verbatim}

De posse da Figura \ref{fig:fig6} como cenário, do algoritmo de atualização \ref{alg:alg1}, e da estrutura de dados previamente descrita,
demonstramos abaixo o estado em que se encontram os dados armazenados em FN2 após a aplicação do método.

\begin{verbatim}
    fogs = [
        {
            ip: '192.168.0.1',
            resources: [ 'ED1' ]
        },
        {
            ip: '192.168.0.3',
            resources: [ ]
        },
        {
            ip: '192.168.0.4',
            resources: [ 'ED1' ]
        },
        {
            ip: '192.168.0.5',
            resources: [ 'ED1', 'ED2' ]
        }
    ];
    myResources = [ 'ED1', 'ED2', 'ED3' ];
\end{verbatim}

Visto isso, é imprescindível que os nodos mantenham seus dados consistentes, pois, após adicionar o novo nodo em sua lista de fogs, o protocolo precisa ser capaz de perceber quando um elemento
deixou de fazer parte do processo. Assim, a manutenção dos estados será abordado de forma similar as mensagens de \textit{keep alive} utilizadas no protocolo BGP, por exemplo.
Mensagens de keep alive são adotadas para que os nodos da rede avisem seus vizinhos que ainda estão em operação, pois, sem esse procedimento seria difícil
saber quando remover um IP da lista de recursos. Portanto, para manter a lista atualizada, este protocolo implementará mensagens desse tipo.

As mensagens de keep alive serão transmitidas sob broadcast em um intervalo de trinta segundos, porém, este é apenas um valor inicial, e conforme o desenvolvimento do projeto esse
parâmetro pode ser ajustado para que a solução obtenha uma eficiência satisfatória.
Após o recebimento da mensagem de keep alive, os nodos deverão respondê-las indicando que ainda estão em operação.
Caso o nodo não responda a mensagem de keep alive, este será marcado como parcialmente inativo pelo remetente da mensagem.
Quando o nodo solicitante realizar outra mensagem de keep alive e o nodo que já estava marcado com parcialmente inativo não responder, o mesmo será removido da lista de recursos do
solicitante, e assim é possível saber quando um nodo deixou de fazer parte da névoa.
Para realizar este controle será preciso adicionar na estrutura \textit{Fog} a propriedade boleana, denominada \textit{isRespondingKeepAlive}, que indica se o nodo esta respondendo a solicitações de keep alive.

% SJF: Já podes definir aqui como vai funcionar todo o protocolo de maneira geral, sem incluir muitos detalhes. Não importa se algo vai mudar posteriormente. O importante é deixar claro que estás pensando em todos os detalhes, não como vais resolver todos os problemas.

% colocar fluxo do keep alive?
% preciso explicar o esquema da epoca ainda.. esse com ctz precisará de desenhos
% as imagens nao estao no lugar que eu gostaria por enquanto, mas quando terminar de escrever ajusto o lugar delas.
% a imagem da pilha de protocolos mostra IPv6, mas no texto me refiro a ipv4. vou ajustar a imagem.

% Para que as mensagens de keep alive funcionem no protocolo de mapeamento de recursos será preciso adicionar uma nova propriedade na estrutura de dados já proposta.
% Esta propriedade, denominada \textit{epoch}, será do tipo inteiro e indicará a versão do estado em que o nodo se encontra.

% quando tver altracao, nao faz nada.... quando alguem for usar recurso q nao existe mais. atualiza epoca e responde responde not found.
% jundo das respostas manda epoca atualizada.
% no proximo keepalive a epoca vai ser diferente. ai todos fazem query.

% api list add delete gerenciamento local da lista



\section{Resultados esperados}

Espera-se que este trabalho resulte em um protocolo funcional a nível de prova de conceito e que seja capaz de descobrir e sincronizar recursos de dispositivos sob computação em névoa.
Além disso, temos como objetivo fazer com que a névoa configure-se de forma autônoma, ou seja, quando um recurso ou nodo entrar ou sair da rede, a mesma deverá manter-se coerente.
% SJF: Podes incluir aqui alguma informação de como pretendes integrar teu projeto. Por exemplo, qual ambiente vai ser usado, quais os outros frameworks / bibliotecas que serão usados para a tua implementação, etc.

\section{Validação}


% topologia de rede simulada com nodos contendo edge devices e rodando o protocolo


Para validarmos o funcionamento do protocolo, utilizaremos um simulador de dispositivos a ser definido no decorrer deste TCC.
Estes dispositivos executarão o \textit{middleware} citado no item 3.2.1 deste trabalho.

\section{Cenários de teste}

\begin{itemize}
    \item Entrada de algum equipamento na rede e este anunciando seus recursos. 
    \item Atualização das listas globais quando algum equipamento deixar de responder as mensagens de \textit{keep alive}.
    \item Utilização de recursos de nodos da rede.
    \item Desligamento de recursos de algum dispositivo da rede, e posterior a isso, a tentativa de acesso a esse recurso por algum nodo.
    O equipamento que perdeu o recurso deverá anunciar seus novos recursos atualizando a lista global dos outros nodos da névoa.
\end{itemize}

% SJF: Tens que escrever essa parte. Podes explorar um cenário como exemplo, colocando figuras para deixar mais claro como esse cenário funciona.












